/**
 * Cloudinary upload utility for direct browser-to-Cloudinary uploads.
 *
 * This module handles the client-side upload to Cloudinary using signed upload URLs
 * generated by the server API.
 */

/**
 * Upload URL data returned from the server API.
 */
export interface UploadUrlData {
  uploadUrl: string;
  publicId: string;
  signature: string;
  timestamp: number;
  apiKey: string;
  cloudName: string;
  folder: string;
  resourceType: 'image' | 'video';
}

/**
 * Cloudinary upload response.
 */
export interface CloudinaryUploadResponse {
  /** The unique identifier for the uploaded asset */
  public_id: string;
  /** The version number of the uploaded asset */
  version: number;
  /** The signature of the response */
  signature: string;
  /** Width of the uploaded image/video */
  width: number;
  /** Height of the uploaded image/video */
  height: number;
  /** Format of the uploaded file (e.g., 'jpg', 'png', 'mp4') */
  format: string;
  /** Resource type ('image' or 'video') */
  resource_type: 'image' | 'video';
  /** Timestamp when the asset was created */
  created_at: string;
  /** Array of tags associated with the asset */
  tags: string[];
  /** Number of bytes of the uploaded file */
  bytes: number;
  /** File type */
  type: string;
  /** Unique identifier for tracking */
  etag: string;
  /** Placeholder URL (for progressive images) */
  placeholder: boolean;
  /** Full URL to access the asset */
  url: string;
  /** Secure HTTPS URL to access the asset */
  secure_url: string;
  /** Folder where the asset is stored */
  folder: string;
  /** Original filename */
  original_filename: string;
  /** Duration for video files (in seconds) */
  duration?: number;
  /** Frame rate for video files */
  frame_rate?: number;
  /** Bit rate for video files */
  bit_rate?: number;
  /** Number of pages (for PDFs) */
  pages?: number;
}

/**
 * Error thrown when Cloudinary upload fails.
 */
export class CloudinaryUploadError extends Error {
  constructor(
    message: string,
    public readonly statusCode?: number,
    public readonly cloudinaryError?: unknown
  ) {
    super(message);
    this.name = 'CloudinaryUploadError';
  }
}

/**
 * Options for the upload function.
 */
export interface UploadOptions {
  /** Callback for upload progress (0-100) */
  onProgress?: (progress: number) => void;
  /** AbortSignal for cancellation */
  signal?: AbortSignal;
}

/**
 * Upload a file directly to Cloudinary using signed upload parameters.
 *
 * @param file - The file to upload
 * @param uploadData - Signed upload parameters from the server API
 * @param options - Optional configuration including progress callback
 * @returns Promise resolving to Cloudinary upload response
 * @throws CloudinaryUploadError if upload fails
 *
 * @example
 * ```typescript
 * // Get signed upload URL from server
 * const res = await fetch(`/api/trips/${tripId}/media/upload-url`, {
 *   method: 'POST',
 *   body: JSON.stringify({ type: 'photo' }),
 * });
 * const { data: uploadData } = await res.json();
 *
 * // Upload file to Cloudinary
 * const result = await uploadToCloudinary(file, uploadData, {
 *   onProgress: (progress) => console.log(`${progress}% uploaded`),
 * });
 *
 * console.log(result.secure_url);
 * ```
 */
export async function uploadToCloudinary(
  file: File,
  uploadData: UploadUrlData,
  options?: UploadOptions
): Promise<CloudinaryUploadResponse> {
  const { uploadUrl, publicId, signature, timestamp, apiKey, folder } = uploadData;
  const { onProgress, signal } = options || {};

  // Build FormData with signed upload parameters
  const formData = new FormData();
  formData.append('file', file);
  formData.append('public_id', publicId);
  formData.append('signature', signature);
  formData.append('timestamp', timestamp.toString());
  formData.append('api_key', apiKey);
  formData.append('folder', folder);

  // Use XMLHttpRequest for progress tracking
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    // Handle abort signal
    if (signal) {
      signal.addEventListener('abort', () => {
        xhr.abort();
        reject(new CloudinaryUploadError('Upload cancelled'));
      });
    }

    // Track upload progress
    if (onProgress) {
      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable) {
          const progress = Math.round((event.loaded / event.total) * 100);
          onProgress(progress);
        }
      });
    }

    // Handle successful upload
    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          const response = JSON.parse(xhr.responseText) as CloudinaryUploadResponse;
          resolve(response);
        } catch (parseError) {
          reject(
            new CloudinaryUploadError(
              'Failed to parse Cloudinary response',
              xhr.status,
              parseError
            )
          );
        }
      } else {
        let errorMessage = 'Upload failed';
        let cloudinaryError: unknown;

        try {
          const errorResponse = JSON.parse(xhr.responseText);
          errorMessage = errorResponse.error?.message || errorMessage;
          cloudinaryError = errorResponse;
        } catch {
          // Response is not JSON, use status text
          errorMessage = xhr.statusText || errorMessage;
        }

        reject(new CloudinaryUploadError(errorMessage, xhr.status, cloudinaryError));
      }
    });

    // Handle network errors
    xhr.addEventListener('error', () => {
      reject(new CloudinaryUploadError('Network error during upload'));
    });

    // Handle timeout
    xhr.addEventListener('timeout', () => {
      reject(new CloudinaryUploadError('Upload timed out'));
    });

    // Handle abort
    xhr.addEventListener('abort', () => {
      reject(new CloudinaryUploadError('Upload cancelled'));
    });

    // Open connection and send
    xhr.open('POST', uploadUrl);
    xhr.send(formData);
  });
}

/**
 * Get a thumbnail URL from a Cloudinary URL.
 *
 * @param url - Original Cloudinary URL
 * @param options - Thumbnail options
 * @returns Transformed URL with thumbnail dimensions
 */
export function getCloudinaryThumbnailUrl(
  url: string,
  options: { width?: number; height?: number } = {}
): string {
  const { width = 400, height = 400 } = options;

  // Find the upload/ segment and insert transformation
  const uploadIndex = url.indexOf('/upload/');
  if (uploadIndex === -1) {
    return url;
  }

  const baseUrl = url.substring(0, uploadIndex + 8); // Include '/upload/'
  const remainder = url.substring(uploadIndex + 8);

  // Create transformation string with auto format and quality
  const transformation = `c_fill,w_${width},h_${height},f_auto,q_auto`;

  return `${baseUrl}${transformation}/${remainder}`;
}

/**
 * Determine media type from file MIME type.
 *
 * @param file - File to check
 * @returns 'photo' or 'video'
 */
export function getMediaTypeFromFile(file: File): 'photo' | 'video' {
  return file.type.startsWith('video/') ? 'video' : 'photo';
}

/**
 * Validate file for upload.
 *
 * @param file - File to validate
 * @param options - Validation options
 * @returns Validation result with error message if invalid
 */
export function validateUploadFile(
  file: File,
  options: {
    maxSizeBytes?: number;
    allowedImageTypes?: string[];
    allowedVideoTypes?: string[];
  } = {}
): { valid: boolean; error?: string } {
  const {
    maxSizeBytes = 100 * 1024 * 1024, // 100MB default
    allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/heic', 'image/heif'],
    allowedVideoTypes = ['video/mp4', 'video/quicktime', 'video/webm', 'video/x-msvideo'],
  } = options;

  // Check file size
  if (file.size > maxSizeBytes) {
    const maxSizeMB = Math.round(maxSizeBytes / (1024 * 1024));
    return { valid: false, error: `File size exceeds ${maxSizeMB}MB limit` };
  }

  // Check file type
  const allowedTypes = [...allowedImageTypes, ...allowedVideoTypes];
  if (!allowedTypes.includes(file.type)) {
    return { valid: false, error: `File type ${file.type} is not supported` };
  }

  return { valid: true };
}
